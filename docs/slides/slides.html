<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Status &amp; Planning Deck">
  <meta name="dcterms.date" content="2023-05-15">
  <title>Lineage &amp; Metadata</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="dzslides.css">
</head>
<body>
<section class="title">
  <h1 class="title">Lineage &amp; Metadata</h1>
  <footer>
    <span class="author">Status &amp; Planning
Deck</span> ¬∑ <span class="date">May 15, 2023</span>
  </footer>
</section>
<section id="core-metadata-model" class="slide level1">
<h1>Core Metadata Model</h1>
<p>AKA Tags / Properties / Attributes for data assets.<br />
Tags help us to encode 605-specific business logic.</p>
<h3 id="tags-are-optional">Tags are <strong>optional</strong>:</h3>
<ul class="incremental">
<li>None of these tags are required anywhere</li>
<li>But <em>best-practice</em> is that every asset Atlan tracks should
have as many tags as possible.</li>
</ul>
<h3 id="tags-are-reusable">Tags are <strong>reusable</strong>:</h3>
<ul class="incremental">
<li>Can be attached to any data assets Atlan is tracking,</li>
<li>But also to documentation-assets or process-assets
(i.e.¬†data-pipelines )</li>
</ul>
<h3 id="tags-are-automatic">Tags are <strong>automatic</strong>:</h3>
<ul class="incremental">
<li><strong>With caveats!</strong></li>
<li>Best mechanism for this is propagating tags ‚Äúdownstream‚Äù, but this
requires lineage telemetry already flowing in.</li>
<li>There are other rule-based ways to do this, but we have to define
the rules.</li>
<li>‚ûî Propagate tags between docs &amp; related data-assets.<br />
</li>
<li>‚ûî Ex: <em>Advisories on Tables become visible on landing pages for
VendorX &amp; sync to Jira</em>.</li>
<li>Overall, bootstrap is <strong>much</strong> easier when we have
<strong>some</strong> high quality metadata that‚Äôs already
available.</li>
</ul>
</section>
<section id="core-metadata-model-1" class="slide level1">
<h1>Core Metadata Model</h1>
<h2 id="case-study-data-deletion-compliance">Case-study: Data-Deletion
Compliance</h2>
<p>With asset time-stamps available by default, we only need 1 tag for
this use-case:</p>
<pre><code>vendor_list: (type=List[Vendor])
  description:
    Describes the vendor(s) associated with this
    data.  (Core-datasets will have 1 vendor;
    derivative data from joins may have several.)</code></pre>
<ul class="incremental">
<li><p>
Several ways this tag can be made initially available, but after it‚Äôs
set once then it can propagate downstream. <em>Data</em> changes
frequently but dataset <em>properties</em> are fairly static.
</p></li>
</ul>
<ul class="incremental">
<li><p>
Flagging deletion-candidates is the hard part here. Then, the business
process for deletion is still open: automatic or interactive. We can
discuss/accept/reject the deletion-proposal in any combination of
Atlan/Jira/Slack with an automated process.
</p></li>
</ul>
<ul class="incremental">
<li><p>
If/when we delete data, empty Atlan search results afterwards
<strong>are</strong> our deletion certs.
</p></li>
</ul>
</section>
<section id="core-metadata-model-2" class="slide level1">
<h1>Core Metadata Model</h1>
<h2 id="use-case-data-driven-decisions-about-storage-costs">Use Case:
Data-driven Decisions About Storage Costs</h2>
<p>Some storage stats are easy, in fact <em>we automatically know the
location/size/last write/storage unit-cost for everything in the
DataCatalog.</em></p>
<p>But connecting these stats back to details about business-operations
is what we usually want. <strong>Are we holding on to data that we don‚Äôt
need? How does contract-ROI stack up to storage costs?</strong> One
additional tag can do a lot here:</p>
<pre><code>po_list: (type=List[integer])
  description:
    Basically a foreign-key to SalesForce
    product-orders, this tag ties this DataSet
    back to the engagement details with client(s).
    (Deliverable-data has 1 client; intermediate
    data for 605 use may have several.)</code></pre>
<ul class="incremental">
<li><p>
BizOps, Legal, and Compliance all expressed interest in this tag &amp;
related ones like <em>‚Äúclient_list‚Äù</em>.
</p></li>
<li><p>
A <em>‚Äúcontract_type‚Äù</em> attribute for DataSets is interesting to
imagine.. querying for unencumbered data that allows joins might help to
identify new product-lines.
</p></li>
</ul>
</section>
<section id="core-metadata-model-3" class="slide level1">
<h1>Core Metadata Model</h1>
<h2 id="use-case-faster-pipeline-debugging">Use Case: Faster Pipeline
Debugging</h2>
<p><strong>Cheaper Pipeline Development</strong>, <strong>Faster
Pipeline Debugging</strong>, <strong>Higher Data Quality</strong>, and
<strong>Less Spending on Compute</strong> might seem like different
goals, but these are all very closely related.</p>
<p>Tracking a few tags and rallying around them for business-processes
will bring significant improvements to each area almost immediately:</p>
<pre><code>pipeline_version: (type=String)
  description:
    A version-string for the code that wrote this data.
    Combined with info from upstream, this fingerprints
    the whole code-path that made this data.

data_quality_check: (type=URL)
  description:
    A URL for the quality-check job that certified
    this data.  Null if no quality-check has run. URL
    may link to a DAG-run, or a DataBrew job, or a
    Databricks notebook.</code></pre>
</section>
<section id="core-data-catalog" class="slide level1">
<h1>Core Data Catalog</h1>
<h3 id="athena-assets-via-glue-crawlers">Athena Assets via Glue
Crawlers</h3>
<p>Atlan‚Äôs data-ingestion (really, metadata-ingestion) here is
<strong>automatic</strong>, and includes <strong>accurate</strong> and
<strong>up-to-date</strong> details for S3-location, row-count,
timestamps, and data-schema, plus any other detail we get from
tag-propagation.</p>
<ul class="incremental">
<li>This is <strong>live information</strong>, minimizing maintenance
chores on stale Confluence pages.<br />
</li>
<li>This is table-based, so unlike searching S3, <strong>you can
actually find things</strong>.</li>
<li>This decouples data-access from metadata access, which is usually
what we want</li>
<li>This decouples the data itself from the metadata, and makes tagging
feasible.</li>
</ul>
<h3 id="hey-this-is-easy">Hey, this is easy!</h3>
<ul class="incremental">
<li><font color=red>But!</font></li>
<li>‚ûî We have to curate our Glue Crawlers</li>
<li>‚ûî ‚ûî No, seriously. We can‚Äôt just ingest from S3</li>
<li><font color=red><em>Well..</em></font> realistically we already
needed Crawlers, so at least this isn‚Äôt false-work.</li>
</ul>
</section>
<section id="core-data-catalog-1" class="slide level1">
<h1>Core Data Catalog</h1>
<h3 id="assets-via-other-sources">Assets via Other Sources</h3>
<ul class="incremental">
<li><p>
Natively, Atlan is capable of directly ingesting metadata from other
sources, including <em>Databricks</em> and <em>Redshift</em>. Those are
still options, but using Athena is preferred, because glue-crawlers
<strong>directly facilitate</strong> follow-up work with ETLs or
DataBrew.
</p></li>
</ul>
<ul class="incremental">
<li><p>
<strong>Clickhouse</strong> is an outlier, and there was some question
about whether this was just a ‚Äúview‚Äù on the datalake. But feedback here
says there is some value, and PoC‚Äôs show that Atlan can accommodate.
</p></li>
</ul>
</section>
<section id="pipelines-data-lineage" class="slide level1">
<h1>Pipelines &amp; Data Lineage</h1>
<h3 id="preferred-mechanism-for-tag-propagation">Preferred Mechanism for
Tag-Propagation</h3>
<p>To know basic information like the <em>vendor</em> or <em>client</em>
for a given dataset, we can‚Äôt rely on individually tagging everything
because of sheer volume.</p>
<p>Luckily most tags like this can be inherited from ‚Äúupstream‚Äù. As an
example: The <em>vendors</em> for a derivative data-set are just the
combined vendor-info for the constituents. This can only work if we are
capturing the ‚Äúupstream‚Äù relationship. Lineage is how we do that.</p>
<h3 id="lineage-captures-pipeline-details">Lineage Captures Pipeline
Details</h3>
<p>Besides facilitating a bunch of tagging that then enables business
logic, making implicit pipeline-dependencies <em>and</em>
data-dependencies explicit is itself very useful:</p>
<ul class="incremental">
<li><p>
<strong>When pipelines fail,</strong> we know what downstream pipelines
cannot run, or may have to run with incomplete/incorrect data.
</p></li>
<li><p>
Visibility on explicit status &amp; deps is good for humans, but also
<strong>implies pipelines can decide for themselves whether they are
ready to run</strong>. This saves tons of human effort spent on
alignment, &amp; also fixes the problem that time-based no-conflict
scheduling rules are hard to decide on, and fundamentally can‚Äôt scale.
</p></li>
<li><p>
<strong>Onboarding / offboarding whole data-products
efficiently</strong> basically requires explicit relationships between
pipelines/data. Doing this right can save us a lot of money and
confusion.
</p></li>
</ul>
</section>
<section id="pipelines-data-lineage-1" class="slide level1">
<h1>Pipelines &amp; Data Lineage</h1>
<h3 id="pipeline-deps-reflect-org-level-deps">Pipeline Deps Reflect
Org-level Deps</h3>
<p>Jira is great, but as a data-company, cross-department collaboration
ultimately happens <em>with data, and on data</em>.</p>
<p>Most pipelines can‚Äôt run without making assumptions about the health
and quality of their parent-pipelines. Most pipelines <em>shouldn‚Äôt</em>
run if that information is completely missing.</p>
<p>A few practical observations:</p>
<ul>
<li><p><strong>We already have to organize work along these lines
anyway,</strong> by considering upstream/downstream. But the problems of
ordering new work and alignment involved usually require several
department-heads and SMEs to unpack and resolve.</p></li>
<li><p><strong>We already have to conduct debugging by considering
what‚Äôs going on upstream.</strong> But the people doing that debugging
are likely only SMEs for their pipeline, and not for the entire
datalake. <em>Even if we assume that debugging happens during
development and not in production,</em> the cost and the frustration
involved here is huge.</p></li>
</ul>
</section>
<section id="pipelines-data-lineage-2" class="slide level1">
<h1>Pipelines &amp; Data Lineage</h1>
<h3 id="implementation-details-loe">Implementation Details &amp;
LOE</h3>
<p><strong>Required lineage-related tagging</strong> only uses
information pipelines are already handling:</p>
<pre><code>s3_output: (type=str)
  description:
    Specific S3 URI for the data this process is creating

s3_inputs: (type=List[str])
  description:
    A list of S3 URIs used as input for this output.</code></pre>
<p><strong>Optionally,</strong> pipelines can push any other tag defined
by the Core Metadata Model. Airflow DAGs in particular are the best
place for us to do as much additional annotation as possible for tags
like <em>‚Äúvendor‚Äù</em> and <em>‚Äúclient‚Äù</em>. As an orchestration
platform, Airflow often already has these details, plus tagging here
helps to keep these details from leaking into ETL code, notebooks,
etc.</p>
<p>From a caller‚Äôs perspective like an Airflow DAG or a Databricks
notebook, pushing this data is done by calling a Lambda.</p>
</section>
<section id="status" class="slide level1">
<h1>Status</h1>
<h3 id="status-summary">Status Summary</h3>
<ul class="incremental">
<li><p>
üü¢ <strong>Vendor Selection:</strong> Atlan seems to be a clear winner
here, and after lots of design / PoCs it‚Äôs always been flexible enough
to even accommodate weirder use-cases. Our needs as far as
business-logic will never have a completely ‚Äúno-code‚Äù solution, but
Atlan‚Äôs SDK has made huge improvements since we started looking, and new
integrations are becoming available all the time.
</p></li>
</ul>
<ul class="incremental">
<li><p>
üü¢ <strong>Core Metadata Model:</strong> This list may never be
<em>finished</em> but it‚Äôs good enough to use, reflects what we know
about needs from several departments, and gives us room to grow.
</p></li>
</ul>
<ul class="incremental">
<li><p>
üî¥ <strong>Core Data Catalog:</strong> Our Glue-Crawlers need serious
attention: we have stuff that is stale / misconfigured as well as stuff
that‚Äôs been completely skipped. Crawler creation &amp; curation
historically have been optional. <em>But Crawlers <em>are</em> our Core
Catalog, not s3</em>. Proceeding as if this were not true hurts us in
many ways, and several of those ways are completely independent of
efforts related to metadata/lineage.
</p></li>
</ul>
</section>
<section id="status-1" class="slide level1">
<h1>Status</h1>
<h3 id="status-summary-1">Status Summary</h3>
<ul class="incremental">
<li><p>
üü° <strong>Pipeline Lineage:</strong>
</p></li>
<li>Client-side, pushing lineage from our pipelines is easy today
regardless of pipeline-type, maybe <em>really</em> easy if we‚Äôre
starting from airflow.<br />
</li>
<li>But this assumes the pipelines we‚Äôre looking at are <em>reasonably
modern</em>. Ad-hoc pipelines outside of version control or things
running on completely deprecated platforms need to address tech-debt
first.</li>
<li>On the backend, stuff that makes lineage useful is still hard. The
main reason for that is trying to accommodate lineage even with our
incomplete catalog, and most of that complexity goes away if we simply
fix the catalog.</li>
</ul>
<ul class="incremental">
<li><p>
üü° <strong>Living Documentation:</strong>
</p></li>
<li>Living documentation gets a section here, and PoCs have started to
show what‚Äôs possible. This deserves more attention, since it ties
everything together and is the obvious place to start collaboration,
search, and dashboarding.</li>
</ul>
</section>
<section id="moving-forward" class="slide level1">
<h1>Moving Forward</h1>
<h3 id="basic-assumptions">Basic Assumptions</h3>
<p>Atlan is essentially a tool that can facilitate the whole
<strong>data-lifecycle</strong>. Because everyone is involved in that
life-cycle here‚Äôs some things we should probably take for granted:</p>
<ul>
<li><p>One person or team can‚Äôt make metadata/lineage magically work for
605.</p></li>
<li><p>There is no team/product/data that doesn‚Äôt have <em>both</em>
interests <em>and</em> obligations in terms of 605 metadata.</p></li>
</ul>
<h3 id="more-controversial-assumptions">More Controversial
Assumptions</h3>
<ul>
<li><p>It‚Äôs not OK for a data-company to not know where their data is,
what it‚Äôs for, where it comes from, and where it‚Äôs going.</p></li>
<li><p>In the end you can‚Äôt plan to fix this by ‚Äúgetting the right
people in meetings‚Äù because actually at some level,
<strong>everyone</strong> needs to know this almost daily.</p></li>
</ul>
</section>
<section id="moving-forward-1" class="slide level1">
<h1>Moving Forward</h1>
<h3 id="blockers-circular-dependencies-the-adoption-problem">Blockers,
Circular Dependencies &amp; the Adoption Problem</h3>
<p>Here‚Äôs a trace of a typical problem, where maybe it‚Äôs easier to see
the vicious circle we‚Äôre in.</p>
<ul class="incremental">
<li><p>
We don‚Äôt want to migrate documentation to Atlan because attaching live
schema-metadata/table-instances to those docs is half the value, and
this info is missing.
</p></li>
</ul>
<ul class="incremental">
<li><p>
Schema details can‚Äôt be attached because they weren‚Äôt ingested because
the Data Catalog is broken.
</p></li>
</ul>
<ul class="incremental">
<li><p>
Without documentation/dashboards, there‚Äôs no useful baseline landing
page to bring anyone to Atlan as the easiest way to start their project.
No traffic means no interest in iterative improvements. And no
improvements to visibility ensures that need-to-know information stays
in silos.
</p></li>
</ul>
<ul class="incremental">
<li><p>
Outside Atlan, because the Data Catalog is neglected, pipelines that
should be trivial with tools like DataBrew end up as large projects that
we get from vendors and have trouble maintaining later.
</p></li>
</ul>
<ul class="incremental">
<li><p>
Legacy maintenance then reduces engineering availability to fix
crawlers, reducing interest in a better approach for docs; missing docs
increases friction for other project startups and silent errors for
established pipelines; and ‚Ä¶. you get the idea.
</p></li>
</ul>
</section>
<section id="moving-forward-2" class="slide level1">
<h1>Moving Forward</h1>
<h3 id="fixing-alignment-by-adding-feedback-loops">Fixing Alignment by
Adding Feedback Loops</h3>
<p>Fundamental causes for the situation on the last slide might be
summarized like this:</p>
<ul class="incremental">
<li><p>
There‚Äôs a sense that nothing can be done until everything else is done.
</p></li>
<li><p>
In general, it‚Äôs really hard to get work done across team/department
boundaries.
</p></li>
<li><p>
Reading between the lines a bit, maybe we‚Äôre all naturally more
interested in <strong>consuming</strong> metadata than we are in
<strong>producing</strong> it.
</p></li>
<li><p>
One way of fixing this is to start thinking of Atlan as a system that
sits at the interface between departments/teams.
</p></li>
</ul>
</section>
<section id="moving-forward-3" class="slide level1">
<h1>Moving Forward</h1>
<h3 id="fixing-alignment-by-adding-feedback-loops-1">Fixing Alignment by
Adding Feedback Loops</h3>
<p>Quoting from an earlier slide: <strong>Jira is great, but as a
data-company, cross-department collaboration ultimately happens with
data, and on data.</strong></p>
<p>Obviously we wouldn‚Äôt get rid of Jira, and actually Atlan integrates
with Jira. Jira tickets that are cut via Atlan are actually likely to
have much better information from the start.</p>
<ul class="incremental">
<li>For example: work <em>begins</em> with reference to a concrete S3
URI, rather than a vendor name + research-task to <em>find</em> the
latest location for the data, find schema details, health-info and the
rest.</li>
</ul>
</section>
<section id="moving-forward-4" class="slide level1">
<h1>Moving Forward</h1>
<h3 id="fixing-alignment-by-adding-feedback-loops-2">Fixing Alignment by
Adding Feedback Loops</h3>
<p><strong>Bugs in our metadata, including missing/incomplete details,
are serious.</strong> These essentially correspond directly to existing
bugs with compliance, or inefficiencies in storage/compute, or future
bugs in pipelines.</p>
<p><strong>Treating this seriously means that:</strong></p>
<ul class="incremental">
<li>Cross-team communication works via Atlan as much as possible</li>
<li>Teams own different parts of the data-lifecycle, but Atlan is always
the SSoT for related metadata.</li>
<li>Teams should be able <em>task each other</em> to fix problems with
Atlan and have confidence it will get done.</li>
<li>DataSets don‚Äôt exist unless they are properly onboarded into
Atlan</li>
<li>Pipelines don‚Äôt start on random/undefined datasets</li>
<li>Pipelines don‚Äôt start with data of unknown quality, and quality
checks haven‚Äôt happened if they aren‚Äôt recorded in public</li>
<li>Docs didn‚Äôt happen if they don‚Äôt exist in Atlan</li>
</ul>
</section>
<section id="moving-forward-5" class="slide level1">
<h1>Moving Forward</h1>
<h3 id="standardization-formal-automated-processes">Standardization
&amp; Formal, Automated Processes</h3>
<p>We won‚Äôt get far with the point of view that sure, everyone‚Äôs job is
way easier if they can <em>consume</em> metadata, but no one wants to
<em>produce</em> it, even if that means 1 new line of code, or 1
additional step to an existing business process.</p>
<p>‚ÄúLineage for thee and not for me‚Äù usually comes with an argument that
the case under consideration is somehow exceptional.</p>
<p><strong>But this is the baseline:</strong></p>
<ul class="incremental">
<li><p>
If data is worth storing, we should know exactly what it‚Äôs for and when
it‚Äôs used, otherwise we need the budget to literally store it forever.
</p></li>
</ul>
<ul class="incremental">
<li><p>
If data is worth computing, it‚Äôs worth testing, otherwise why bother?
</p></li>
</ul>
<ul class="incremental">
<li><p>
If compute is worth running once, it probably runs semi-frequently and
is part of a family of related tasks, so it belongs in a structured
pipeline. Ad-hoc stuff threatens business continuity, stability, and
quality because it just isn‚Äôt maintainable, reproducible, or deployable.
</p></li>
</ul>
<ul class="incremental">
<li><p>
The rest of the org really needs this stuff from you, even if you‚Äôre not
interested! If this costs you effort in one spot, it saves effort in
another when you can rely on <em>consuming</em> metadata as well as
<em>producing it</em>
<p></li>
</ul>
</section>
<!-- {{{{ dzslides core
#
#
#     __  __  __       .  __   ___  __
#    |  \  / /__` |    | |  \ |__  /__`
#    |__/ /_ .__/ |___ | |__/ |___ .__/ core :‚Ç¨
#
#
# The following block of code is not supposed to be edited.
# But if you want to change the behavior of these slides,
# feel free to hack it!
#
-->

<div id="progress-bar"></div>

<!-- Default Style -->
<style>
  * { margin: 0; padding: 0; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
  [role="note"] { display: none; }
  body {
    width: 800px; height: 600px;
    margin-left: -400px; margin-top: -300px;
    position: absolute; top: 50%; left: 50%;
    overflow: hidden;
    display: none;
  }
  .view body {
    position: static;
    margin: 0; padding: 0;
    width: 100%; height: 100%;
    display: inline-block;
    overflow: visible; overflow-x: hidden;
    /* undo Dz.onresize */
    transform: none !important;
    -moz-transform: none !important;
    -webkit-transform: none !important;
    -o-transform: none !important;
    -ms-transform: none !important;
  }
  .view head, .view head > title { display: block }
  section {
    position: absolute;
    pointer-events: none;
    width: 100%; height: 100%;
  }
  .view section {
    pointer-events: auto;
    position: static;
    width: 800px; height: 600px;
    margin: -150px -200px;
    float: left;

    transform: scale(.4);
    -moz-transform: scale(.4);
    -webkit-transform: scale(.4);
    -o-transform: scale(.4);
    -ms-transform: scale(.4);
  }
  .view section > * { pointer-events: none; }
  section[aria-selected] { pointer-events: auto; }
  html { overflow: hidden; }
  html.view { overflow: visible; }
  body.loaded { display: block; }
  .incremental {visibility: hidden; }
  .incremental[active] {visibility: visible; }
  #progress-bar{
    bottom: 0;
    position: absolute;
    -moz-transition: width 400ms linear 0s;
    -webkit-transition: width 400ms linear 0s;
    -ms-transition: width 400ms linear 0s;
    transition: width 400ms linear 0s;
  }
  .view #progress-bar {
    display: none;
  }
</style>

<script>
  var Dz = {
    remoteWindows: [],
    idx: -1,
    step: 0,
    html: null,
    slides: null,
    progressBar : null,
    params: {
      autoplay: "1"
    }
  };

  Dz.init = function() {
    document.body.className = "loaded";
    this.slides = Array.prototype.slice.call($$("body > section"));
    this.progressBar = $("#progress-bar");
    this.html = document.body.parentNode;
    this.setupParams();
    this.onhashchange();
    this.setupTouchEvents();
    this.onresize();
    this.setupView();
  }

  Dz.setupParams = function() {
    var p = window.location.search.substr(1).split('&');
    p.forEach(function(e, i, a) {
      var keyVal = e.split('=');
      Dz.params[keyVal[0]] = decodeURIComponent(keyVal[1]);
    });
  // Specific params handling
    if (!+this.params.autoplay)
      $$.forEach($$("video"), function(v){ v.controls = true });
  }

  Dz.onkeydown = function(aEvent) {
    // Don't intercept keyboard shortcuts
    if (aEvent.altKey
      || aEvent.ctrlKey
      || aEvent.metaKey
      || aEvent.shiftKey) {
      return;
    }
    if ( aEvent.keyCode == 37 // left arrow
      || aEvent.keyCode == 38 // up arrow
      || aEvent.keyCode == 33 // page up
    ) {
      aEvent.preventDefault();
      this.back();
    }
    if ( aEvent.keyCode == 39 // right arrow
      || aEvent.keyCode == 40 // down arrow
      || aEvent.keyCode == 34 // page down
    ) {
      aEvent.preventDefault();
      this.forward();
    }
    if (aEvent.keyCode == 35) { // end
      aEvent.preventDefault();
      this.goEnd();
    }
    if (aEvent.keyCode == 36) { // home
      aEvent.preventDefault();
      this.goStart();
    }
    if (aEvent.keyCode == 32) { // space
      aEvent.preventDefault();
      this.toggleContent();
    }
    if (aEvent.keyCode == 70) { // f
      aEvent.preventDefault();
      this.goFullscreen();
    }
    if (aEvent.keyCode == 79) { // o
      aEvent.preventDefault();
      this.toggleView();
    }
  }

  /* Touch Events */

  Dz.setupTouchEvents = function() {
    var orgX, newX;
    var tracking = false;

    var db = document.body;
    db.addEventListener("touchstart", start.bind(this), false);
    db.addEventListener("touchmove", move.bind(this), false);

    function start(aEvent) {
      aEvent.preventDefault();
      tracking = true;
      orgX = aEvent.changedTouches[0].pageX;
    }

    function move(aEvent) {
      if (!tracking) return;
      newX = aEvent.changedTouches[0].pageX;
      if (orgX - newX > 100) {
        tracking = false;
        this.forward();
      } else {
        if (orgX - newX < -100) {
          tracking = false;
          this.back();
        }
      }
    }
  }

  Dz.setupView = function() {
    document.body.addEventListener("click", function ( e ) {
      if (!Dz.html.classList.contains("view")) return;
      if (!e.target || e.target.nodeName != "SECTION") return;

      Dz.html.classList.remove("view");
      Dz.setCursor(Dz.slides.indexOf(e.target) + 1);
    }, false);
  }

  /* Adapt the size of the slides to the window */

  Dz.onresize = function() {
    var db = document.body;
    var sx = db.clientWidth / window.innerWidth;
    var sy = db.clientHeight / window.innerHeight;
    var transform = "scale(" + (1/Math.max(sx, sy)) + ")";

    db.style.MozTransform = transform;
    db.style.WebkitTransform = transform;
    db.style.OTransform = transform;
    db.style.msTransform = transform;
    db.style.transform = transform;
  }


  Dz.getNotes = function(aIdx) {
    var s = $("section:nth-of-type(" + aIdx + ")");
    var d = s.$("[role='note']");
    return d ? d.innerHTML : "";
  }

  Dz.onmessage = function(aEvent) {
    var argv = aEvent.data.split(" "), argc = argv.length;
    argv.forEach(function(e, i, a) { a[i] = decodeURIComponent(e) });
    var win = aEvent.source;
    if (argv[0] === "REGISTER" && argc === 1) {
      this.remoteWindows.push(win);
      this.postMsg(win, "REGISTERED", document.title, this.slides.length);
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
      return;
    }
    if (argv[0] === "BACK" && argc === 1)
      this.back();
    if (argv[0] === "FORWARD" && argc === 1)
      this.forward();
    if (argv[0] === "START" && argc === 1)
      this.goStart();
    if (argv[0] === "END" && argc === 1)
      this.goEnd();
    if (argv[0] === "TOGGLE_CONTENT" && argc === 1)
      this.toggleContent();
    if (argv[0] === "SET_CURSOR" && argc === 2)
      window.location.hash = "#" + argv[1];
    if (argv[0] === "GET_CURSOR" && argc === 1)
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
    if (argv[0] === "GET_NOTES" && argc === 1)
      this.postMsg(win, "NOTES", this.getNotes(this.idx));
  }

  Dz.toggleContent = function() {
    // If a Video is present in this new slide, play it.
    // If a Video is present in the previous slide, stop it.
    var s = $("section[aria-selected]");
    if (s) {
      var video = s.$("video");
      if (video) {
        if (video.ended || video.paused) {
          video.play();
        } else {
          video.pause();
        }
      }
    }
  }

  Dz.setCursor = function(aIdx, aStep) {
    // If the user change the slide number in the URL bar, jump
    // to this slide.
    aStep = (aStep != 0 && typeof aStep !== "undefined") ? "." + aStep : ".0";
    window.location.hash = "#" + aIdx + aStep;
  }

  Dz.onhashchange = function() {
    var cursor = window.location.hash.split("#"),
        newidx = 1,
        newstep = 0;
    if (cursor.length == 2) {
      newidx = ~~cursor[1].split(".")[0];
      newstep = ~~cursor[1].split(".")[1];
      if (newstep > Dz.slides[newidx - 1].$$('.incremental > *').length) {
        newstep = 0;
        newidx++;
      }
    }
    this.setProgress(newidx, newstep);
    if (newidx != this.idx) {
      this.setSlide(newidx);
    }
    if (newstep != this.step) {
      this.setIncremental(newstep);
    }
    for (var i = 0; i < this.remoteWindows.length; i++) {
      this.postMsg(this.remoteWindows[i], "CURSOR", this.idx + "." + this.step);
    }
  }

  Dz.back = function() {
    if (this.idx == 1 && this.step == 0) {
      return;
    }
    if (this.step == 0) {
      this.setCursor(this.idx - 1,
                     this.slides[this.idx - 2].$$('.incremental > *').length);
    } else {
      this.setCursor(this.idx, this.step - 1);
    }
  }

  Dz.forward = function() {
    if (this.idx >= this.slides.length &&
        this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
        return;
    }
    if (this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
      this.setCursor(this.idx + 1, 0);
    } else {
      this.setCursor(this.idx, this.step + 1);
    }
  }

  Dz.goStart = function() {
    this.setCursor(1, 0);
  }

  Dz.goEnd = function() {
    var lastIdx = this.slides.length;
    var lastStep = this.slides[lastIdx - 1].$$('.incremental > *').length;
    this.setCursor(lastIdx, lastStep);
  }

  Dz.toggleView = function() {
    this.html.classList.toggle("view");

    if (this.html.classList.contains("view")) {
      $("section[aria-selected]").scrollIntoView(true);
    }
  }

  Dz.setSlide = function(aIdx) {
    this.idx = aIdx;
    var old = $("section[aria-selected]");
    var next = $("section:nth-of-type("+ this.idx +")");
    if (old) {
      old.removeAttribute("aria-selected");
      var video = old.$("video");
      if (video) {
        video.pause();
      }
    }
    if (next) {
      next.setAttribute("aria-selected", "true");
      if (this.html.classList.contains("view")) {
        next.scrollIntoView();
      }
      var video = next.$("video");
      if (video && !!+this.params.autoplay) {
        video.play();
      }
    } else {
      // That should not happen
      this.idx = -1;
      // console.warn("Slide doesn't exist.");
    }
  }

  Dz.setIncremental = function(aStep) {
    this.step = aStep;
    var old = this.slides[this.idx - 1].$('.incremental > *[aria-selected]');
    if (old) {
      old.removeAttribute('aria-selected');
    }
    var incrementals = $$('.incremental');
    if (this.step <= 0) {
      $$.forEach(incrementals, function(aNode) {
        aNode.removeAttribute('active');
      });
      return;
    }
    var next = this.slides[this.idx - 1].$$('.incremental > *')[this.step - 1];
    if (next) {
      next.setAttribute('aria-selected', true);
      next.parentNode.setAttribute('active', true);
      var found = false;
      $$.forEach(incrementals, function(aNode) {
        if (aNode != next.parentNode)
          if (found)
            aNode.removeAttribute('active');
          else
            aNode.setAttribute('active', true);
        else
          found = true;
      });
    } else {
      setCursor(this.idx, 0);
    }
    return next;
  }

  Dz.goFullscreen = function() {
    var html = $('html'),
        requestFullscreen = html.requestFullscreen || html.requestFullScreen || html.mozRequestFullScreen || html.webkitRequestFullScreen;
    if (requestFullscreen) {
      requestFullscreen.apply(html);
    }
  }
  
  Dz.setProgress = function(aIdx, aStep) {
    var slide = $("section:nth-of-type("+ aIdx +")");
    if (!slide)
      return;
    var steps = slide.$$('.incremental > *').length + 1,
        slideSize = 100 / (this.slides.length - 1),
        stepSize = slideSize / steps;
    this.progressBar.style.width = ((aIdx - 1) * slideSize + aStep * stepSize) + '%';
  }
  
  Dz.postMsg = function(aWin, aMsg) { // [arg0, [arg1...]]
    aMsg = [aMsg];
    for (var i = 2; i < arguments.length; i++)
      aMsg.push(encodeURIComponent(arguments[i]));
    aWin.postMessage(aMsg.join(" "), "*");
  }
  
  function init() {
    Dz.init();
    window.onkeydown = Dz.onkeydown.bind(Dz);
    window.onresize = Dz.onresize.bind(Dz);
    window.onhashchange = Dz.onhashchange.bind(Dz);
    window.onmessage = Dz.onmessage.bind(Dz);
  }

  window.onload = init;
</script>


<script> // Helpers
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {

      // closest thing possible to the ECMAScript 5 internal IsCallable
      // function 
      if (typeof this !== "function")
      throw new TypeError(
        "Function.prototype.bind - what is trying to be fBound is not callable"
      );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
            return fToBind.apply( this instanceof fNOP ? this : oThis || window,
                   aArgs.concat(Array.prototype.slice.call(arguments)));
          };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
  }

  var $ = (HTMLElement.prototype.$ = function(aQuery) {
    return this.querySelector(aQuery);
  }).bind(document);

  var $$ = (HTMLElement.prototype.$$ = function(aQuery) {
    return this.querySelectorAll(aQuery);
  }).bind(document);

  $$.forEach = function(nodeList, fun) {
    Array.prototype.forEach.call(nodeList, fun);
  }

</script>
<!-- vim: set fdm=marker: }}} -->
</body>
</html>
